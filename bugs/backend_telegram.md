# Аудит Telegram webhook и регистрации (backend)

Ниже проблемы отсортированы по убыванию критичности.

## Высокая критичность

1. **Публичный доступ к диагностике notify‑бота**
   - **Где**: `GET /telegram/notify/webhook-info`.
   - **Проблема**: эндпоинт не защищён guard’ами и отдаёт публично информацию о вебхуке (URL, ошибки). Это повышает поверхность атаки и позволяет внешним пользователям получать диагностические сведения о боте.
   - **Риск**: упрощение разведки и атак, утечка служебных данных о состоянии интеграции.
   - **Что делать**: закрыть доступ (AdminGuard/AdminIpGuard) или убрать из публичного API.

2. **Тихий отказ обработки notify‑вебхуков при отсутствии секрета**
   - **Где**: `POST /telegram/notify/webhook`.
   - **Проблема**: если `TELEGRAM_NOTIFY_WEBHOOK_SECRET` не задан или пустой, обработчик всегда возвращает `{ ok: true }` и не вызывает `processUpdate()`.
   - **Риск**: уведомления для сотрудников перестают работать без явного сигнала об ошибке (тихий отказ), легко пропустить на проде.
   - **Что делать**: fail‑fast при отсутствии секрета (лог + метрика + healthcheck/ошибка), либо явно разрешить режим без секрета и тогда обрабатывать webhook без проверки.

3. **Регистрация бота помечает интеграцию “активной”, даже если Telegram не принял вебхук**
   - **Где**: `POST /merchants/:id/telegram/register` → `TelegramBotService.registerBot()`.
   - **Проблема**: при ошибке `setWebhook()` метод всё равно записывает токен/секрет в БД и возвращает `success: true`, а API отдаёт `{ ok: true }`.
   - **Риск**: в портале/админке интеграция выглядит подключённой, но Telegram не шлёт события — пользователи не понимают, почему бот «не работает».
   - **Что делать**: при неуспешной установке webhook не включать `telegramBotEnabled`/`isActive`, возвращать ошибку на уровне API (без оверинжиниринга — достаточно `ok: false` и не активировать запись).

## Средняя критичность

4. **Ротация webhook‑секрета не сохраняет секрет, если запись TelegramBot отсутствует**
   - **Где**: `POST /merchants/:id/telegram/rotate-webhook` → `TelegramBotService.rotateWebhookSecret()`.
   - **Проблема**: если строки в таблице `telegramBot` нет, метод устанавливает webhook с новым секретом, но **не сохраняет секрет в БД**. Контроллер в `/telegram/webhook/:merchantId` берёт секрет только из `telegramBot`, из‑за чего последующие вебхуки будут игнорироваться.
   - **Риск**: бот перестанет обрабатывать апдейты после ротации (особенно в legacy‑сценариях/после чистки таблицы).
   - **Что делать**: при отсутствии записи делать `upsert` с новым секретом, как в `registerBot()`/`setupWebhook()`.

5. **Webhook обработчик завязан на in‑memory `bots` и не подгружает конфиг при расхождении данных**
   - **Где**: `POST /telegram/webhook/:merchantId` → `TelegramBotService.processWebhook()`.
   - **Проблема**: даже если в БД есть активный бот, `processWebhook()` использует только `this.bots` (in‑memory Map). Если карта не заполнена/рассинхронизирована (ошибка загрузки, частичный импорт, legacy данные), апдейты будут проигнорированы.
   - **Риск**: «тихий» отказ обработки сообщений после рестартов/миграций.
   - **Что делать**: при отсутствии записи в Map подгружать конфиг через `ensureBotLoaded()` (или fallback к БД), чтобы webhook не зависел от состояния памяти.

6. **Отсутствует валидация критичных env‑URL при регистрации бота**
   - **Где**: `TelegramBotService.registerBot()` и `loadBots()/setupWebhook()`.
   - **Проблема**: `API_BASE_URL`/`MINIAPP_BASE_URL` используются без проверки — при пустом/неверном значении в БД фиксируются некорректные URL (`undefined/...`), webhook устанавливается на неправильный адрес.
   - **Риск**: интеграция «включена», но webhook и miniapp‑ссылка нерабочие; диагностика осложняется.
   - **Что делать**: валидировать env на старте (fail‑fast) или возвращать явную ошибку регистрации при пустом URL.

