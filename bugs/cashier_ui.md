# Аудит кассового интерфейса и связанного API

Ниже перечислены найденные проблемы, отсортированные по убыванию важности.

## Критично

### 1) Коллизии `orderId` из-за очень короткого генератора
**Где:** `cashier/src/app/page.tsx` (генерация `orderId`).

**Почему это проблема:**
- `orderId` участвует в idempotency и уникальности чеков. Сейчас он генерируется как `O-<Date.now() % 1_000_000>` и позже как `O-<Math.random() * 100000>`. Диапазон слишком мал (100k–1M), поэтому при активной кассе возможны коллизии между разными транзакциями.
- Последствия: `commit` может вернуть `alreadyCommitted` для нового заказа, а начисление/списание не произойдёт или уйдёт в чужую транзакцию.

**Доказательства в коде:** `setOrderId('O-' + Math.floor(Date.now() % 1_000_000))`, `setOrderId('O-' + Math.floor(Math.random() * 100000))`.

---

## Высокий приоритет

### 2) Реалтайм‑ивенты лояльности получают некорректный `customerId` для коротких QR‑кодов
**Где:** `cashier/src/app/page.tsx` (парсинг токена и `emitLoyaltyEvent`).

**Почему это проблема:**
- Для JWT `resolveCustomerIdFromToken` извлекает `customerId`, но если QR — это короткий 9‑значный код, функция возвращает сам токен.
- В `emitLoyaltyEvent` это значение отправляется как `customerId`. В итоге подписчики (например, miniapp) не смогут корректно сопоставить событие с реальным клиентом — обновление баланса/ивентов в UI будет некорректным или не сработает вовсе.

**Доказательства в коде:** `resolveCustomerIdFromToken` возвращает `trimmed` при не‑JWT токене и это значение используется при `emitLoyaltyEvent`.

---

## Средний приоритет

### 3) Возвраты ищут чек только в последних 250 транзакциях точки
**Где:** `cashier/src/app/page.tsx` (поиск чека для возврата через `/loyalty/cashier/outlet-transactions`).

**Почему это проблема:**
- Поиск выполняется максимум по 5 страницам по 50 операций. Если чек старше или в точке высокий оборот, возврат не будет найден.
- Это ломает «сквозной» сценарий возврата: кассир знает номер чека, но UI не позволяет оформить возврат, хотя backend это поддерживает.

**Доказательства в коде:** цикл `for (let page = 0; page < 5; page += 1)` и `limit=50`.

