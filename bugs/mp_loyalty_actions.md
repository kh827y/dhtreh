# Аудит loyalty actions / portal/loyalty/promotions

Ниже проблемы отсортированы по убыванию критичности.

## P1 — Высокая важность

### 1) Неверная метрика «уникальные клиенты» в карточке акции
**Риск:** аналитика в карточке акции показывает количество покупок вместо количества уникальных клиентов. Это искажает эффективность промо и приводит к неверным решениям по бюджету/продлению акции.
**Где:** `api/src/loyalty-program/controllers/promotions.controller.ts` (`getById`), вычисление `uniqueCustomers` берёт `metrics.participantsCount`, который инкрементится по покупкам (а не по уникальным клиентам) в `api/src/loyalty/loyalty.service.ts`.
**Почему:** `participantsCount` увеличивается на каждую покупку (см. апдейт метрик), и в `getById` он используется и для `totalUsage`, и для `uniqueCustomers`.
**Как проявляется:** промо с несколькими покупками от одного клиента показывает «уникальных клиентов» больше реального.

### 2) «Начать сразу» не сохраняется как состояние и сбивает ожидания при редактировании
**Риск:** после сохранения акция всегда отображается как «начинается по дате», даже если была создана «сразу». При редактировании включение «начать сразу» ставит `startAt` в `createdAt`, а не в текущий момент, из-за чего промо может считаться начатым задним числом.
**Где:** `merchant-portal/app/loyalty/actions/page.tsx` (`handleSave`, `loadPromotions`, `handleEdit`).
**Почему:** UI всегда отправляет `startAt` (даже при “начать сразу”), а при загрузке промо `startImmediately = !startAt` — то есть фактически всегда `false`. При редактировании и включении «начать сразу» используется `createdAt`, а не `now`.
**Как проявляется:** промо, созданные «сразу», после перезагрузки выглядят как промо с явной датой старта, а при пересохранении могут получить «задним числом» старт.

## P2 — Средняя важность

### 3) Можно повторно «включить» завершённые/отменённые акции из UI
**Риск:** статус в UI группирует `DRAFT/PAUSED/COMPLETED/CANCELED` как «Выключенные». Кнопка «включить» отправляет `ACTIVE` для всех них, что позволяет реактивировать отменённые/завершённые акции без отдельного подтверждения или проверки.
**Где:** `merchant-portal/app/loyalty/actions/page.tsx` (`resolvePromotionStatus`, `handleToggleStatus`).
**Почему:** UI не различает статусы `COMPLETED/CANCELED` и воспринимает их как «disabled», а endpoint принимает `ACTIVE`.
**Как проявляется:** акции, которые должны считаться закрытыми, можно случайно запустить снова.

### 4) Нельзя корректно редактировать акции по скрытым товарам
**Риск:** если товар скрыт в каталоге, он не попадает в список выбора, но акция по нему уже существует. В итоге товар невозможно снять/заменить — промо становится «невозможно отредактировать» корректно.
**Где:** `merchant-portal/app/loyalty/actions/page.tsx` (`loadCatalog` делает `GET /api/portal/catalog/products?status=visible`).
**Почему:** UI грузит только видимые товары, игнорируя уже выбранные «скрытые».
**Как проявляется:** в форме редактирования пропадают скрытые товары из выбора, но остаются в сохранённых `selectedItemIds`.

## P3 — Низкая важность

### 5) Риск смещения даты начала/окончания из‑за UTC‑парсинга
**Риск:** даты промо могут «съезжать» на сутки назад/вперёд в зависимости от часового пояса, потому что `new Date("YYYY-MM-DD")` интерпретируется как UTC.
**Где:** `merchant-portal/app/loyalty/actions/page.tsx` (`handleSave`, `parseDate`).
**Почему:** при сохранении `new Date(formData.startDate/endDate)` и последующий `toISOString()` фиксируют дату в UTC без учёта локальной зоны.
**Как проявляется:** мерчант выбирает дату в UI, а фактический `startAt/endAt` в API оказывается на сутки раньше/позже.
