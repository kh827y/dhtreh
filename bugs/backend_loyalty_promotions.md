# Аудит backend: акции лояльности (portal/loyalty/promotions)

Ниже перечислены найденные проблемы, отсортированные по убыванию критичности.

## P1 — Высокая

### 1) Подмена автора действия через `actorId` в изменении статусов
**Риск:** любой пользователь портала, имеющий доступ к изменению статуса, может передать произвольный `actorId` и подменить автора изменений в аудит‑логе/метриках/уведомлениях. Это ломает контроль доступа и расследования инцидентов (можно «перевесить» действия на другого сотрудника).  
**Где:** `POST /portal/loyalty/promotions/:id/status` и `POST /portal/loyalty/promotions/bulk/status` принимают `actorId` из тела запроса и передают его в `changePromotionStatus/bulkUpdatePromotionStatus`, где он пишется в `updatedById`.【F:api/src/loyalty-program/controllers/promotions.controller.ts†L167-L211】【F:api/src/loyalty-program/loyalty-program.service.ts†L1520-L1586】
**Что проверить/исправить:** брать `actorId` из `req` (контекста портала), а поле из body игнорировать.

### 2) Уведомления по акциям не пересчитываются при изменениях и смене статуса
**Риск:** акции с включёнными уведомлениями могут вообще не отправить push/telegram после активации (если были созданы в статусе DRAFT) или, наоборот, отправить устаревшие уведомления при изменении дат/шаблонов или архивировании. Это приводит к неправильным рассылкам клиентам.  
**Где:** планирование уведомлений запускается только при создании акции и отсутствует при `update`/`status`/`bulk status` изменениях; в `updatePromotion` и `changePromotionStatus` нет пересоздания/отмены задач, а `schedulePromotionNotifications` вызывается только в `createPromotion`.【F:api/src/loyalty-program/loyalty-program.service.ts†L1245-L1292】【F:api/src/loyalty-program/loyalty-program.service.ts†L1295-L1473】【F:api/src/loyalty-program/loyalty-program.service.ts†L1520-L1562】
**Что проверить/исправить:** при смене статуса и изменении дат/шаблонов пересоздавать/отменять задачи коммуникаций (или явно документировать, что уведомления создаются только при создании).

## P2 — Средняя

### 3) Сегменты для акций выбираются без проверки `merchantId`
**Риск:** при создании акции можно указать `segmentId` чужого мерчанта. Далее фильтр сегмента извлекает сегменты по `id` без `merchantId`, что может привести к некорректному применению акции (например, «всем» по чужому системному сегменту) и к косвенному межмерчантному конфликту логики.  
**Где:** акции принимают `segmentId` без валидации на принадлежность мерчанту; фильтрация сегментов в `filterPromotionsForCustomer` использует `customerSegment.findMany` только по `id`.【F:api/src/loyalty-program/loyalty-program.service.ts†L1245-L1266】【F:api/src/loyalty/loyalty.service.ts†L779-L797】
**Что проверить/исправить:** валидировать `segmentId` на принадлежность мерчанту при создании/обновлении акции и добавлять фильтр `merchantId` в сегментные запросы.

### 4) Неверная аналитика уникальных клиентов в деталях акции
**Риск:** метрика `uniqueCustomers` в ответе `/portal/loyalty/promotions/:id` отображается как `participantsCount`, который увеличивается на каждый факт участия/покупки, а не на уникального клиента. В итоге аналитика завышается и вводит в заблуждение.  
**Где:** `uniqueCustomers` берётся из `participantsCount`, а сам счётчик инкрементируется при каждом участии (claims).【F:api/src/loyalty-program/controllers/promotions.controller.ts†L224-L239】【F:api/src/loyalty/loyalty.controller.ts†L734-L759】
**Что проверить/исправить:** хранить отдельный счётчик уникальных клиентов или рассчитывать уникальность на уровне БД, а в ответе разделять «кол-во участий» и «уникальных клиентов».

### 5) Детализация использований акции всегда показывает `rewardType=POINTS`
**Риск:** для скидочных акций в `/portal/loyalty/promotions/:id` возвращается `rewardType: 'POINTS'` и `rewardValue` из `pointsIssued`, что искажает историю и визуализацию механики в портале.  
**Где:** формирование `usages` жёстко задаёт `rewardType: 'POINTS'` без учёта типа акции.【F:api/src/loyalty-program/controllers/promotions.controller.ts†L242-L254】
**Что проверить/исправить:** возвращать тип/значение вознаграждения в зависимости от реального типа акции или скрывать поле для скидочных акций.

## P3 — Низкая

### 6) Баллы по «точечным» акциям без товарных целей не участвуют в расчёте бонусов
**Риск:** акции типа POINTS без привязки к товарам/категориям можно создать (с заданным `rewardValue`), но механизм расчёта бонусов для чеков их никогда не применит, потому что активные промо‑правила игнорируют такие акции. Это даёт расхождение ожиданий портала и фактического начисления баллов.  
**Где:** при создании POINTS‑акции допускаются промо без `productIds/categoryIds`, но в `loadActivePromotionRules` такие акции отфильтровываются (`continue` при `!hasTargets`), а расчёт позиций использует только `loadActivePromotionRules`.【F:api/src/loyalty-program/loyalty-program.service.ts†L1190-L1207】【F:api/src/loyalty/loyalty.service.ts†L338-L386】【F:api/src/loyalty/loyalty.service.ts†L639-L707】
**Что проверить/исправить:** либо запретить создание POINTS‑акций без товарных целей, либо явно поддержать их в расчёте бонусов/чека.

### 7) Отсутствует валидация диапазона дат акции (`startAt`/`endAt`)
**Риск:** можно сохранить акции с `endAt < startAt` или с прошедшими датами при активном статусе — такие акции никогда не активируются/не применяются, но остаются «активными» в UI.  
**Где:** при создании и обновлении даты принимаются как есть, без проверки порядка и логики статуса/дат. 【F:api/src/loyalty-program/loyalty-program.service.ts†L1245-L1266】【F:api/src/loyalty-program/loyalty-program.service.ts†L1415-L1454】
**Что проверить/исправить:** валидировать `startAt <= endAt` и согласованность `status` с датами.
