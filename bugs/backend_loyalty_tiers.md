# Аудит: loyalty tiers (backend + связь с UI)

Ниже — найденные проблемы по убыванию важности.

## 1) Критичная рассинхронизация правил уровней из-за отсутствия серверных ограничений

**Что происходит**
- Валидации для инвариантов уровней есть только на UI, но отсутствуют на бэкенде. Через прямые запросы к API можно:
  - убрать флаг `isInitial` у единственного стартового уровня (или удалить стартовый уровень вовсе);
  - сделать стартовый уровень скрытым (`isHidden=true`),
  - скрыть все уровни.

**Почему это критично**
- Логика начислений/списаний опирается на `isInitial` или активное назначение уровня. Если `isInitial` отсутствует или все уровни скрыты, правила становятся непредсказуемыми:
  - в `loyalty.service.ts` расчёт ставок берёт стартовый уровень только по `isInitial` и не проверяет, что он видимый;
  - авто‑пересчёт прогресса уровней (`recomputeTierProgress`) игнорирует скрытые уровни и просто прекращает обновлять назначения, если все уровни скрыты.
- Это ломает сквозную связку «UI → API → начисления»: UI считает, что базовый/стартовый уровень всегда есть и видим, но бэкенд это не гарантирует.

**Где в коде**
- API уровней: `api/src/loyalty-program/controllers/tiers.controller.ts`, `api/src/loyalty-program/loyalty-program.service.ts` (create/update/delete)
- Расчёт ставок/назначений: `api/src/loyalty/loyalty.service.ts` (`quote`, `getCustomerRates`, `recomputeTierProgress`)
- UI‑ограничения, которые легко обходятся через API: `merchant-portal/app/loyalty/mechanics/levels/page.tsx`

**Что нужно**
- Перенести критичные инварианты в бэкенд:
  - не разрешать оставлять систему без единственного `isInitial`;
  - запретить `isHidden=true` для стартового уровня;
  - запретить «все уровни скрыты» (минимум один видимый уровень).

## 2) Нет серверной защиты от экстремальных процентов начисления/списания

**Что происходит**
- Бэкенд принимает любые значения `earnRatePercent`/`redeemRatePercent` (валидация только на клиенте), и переводит их в bps без верхнего ограничения.
- UI ограничивает `redeemRatePercent <= 100`, но это не enforced на API.

**Риск**
- Можно выставить `redeemRatePercent > 100`, и в расчёте лимита списания (`redeemLimitBps`) получится значение > 10000. При отсутствии `minPaymentAmount` это позволяет списывать больше суммы чека (или вплоть до полного баланса), что открывает абуз баллов.
- Аналогично, завышенный `earnRatePercent` приводит к чрезмерным начислениям.

**Где в коде**
- `api/src/loyalty-program/loyalty-program.service.ts` (`sanitizePercent`, `createTier`, `updateTier`)
- `api/src/loyalty/loyalty.service.ts` (расчёт `redeemLimitBps`/лимитов в quote)
- UI‑проверки только на клиенте: `merchant-portal/app/loyalty/mechanics/levels/page.tsx`

**Что нужно**
- Серверная валидация диапазонов: например, `0 ≤ earnRatePercent ≤ 100`, `0 ≤ redeemRatePercent ≤ 100`.

## 3) Нестабильная пагинация клиентов уровня

**Что происходит**
- Эндпоинт `/portal/loyalty/tiers/:tierId/customers` сортирует по `assignedAt desc, id desc`, но курсор строится только по `id`.

**Риск**
- При наличии одинаковых `assignedAt` или новых назначений между запросами возможны пропуски/дубли элементов при пагинации.
- В UI это проявится как некорректная выдача при «Загрузить ещё».

**Где в коде**
- `api/src/loyalty-program/controllers/tiers.controller.ts` (параметры пагинации)
- `api/src/loyalty-program/loyalty-program.service.ts` (`listTierCustomers`, порядок сортировки и cursor)
- UI: `merchant-portal/components/TierMembersModal.tsx`

**Что нужно**
- Либо использовать курсор по составному ключу (`assignedAt + id`), либо сортировать только по `id` и использовать его как курсор.
