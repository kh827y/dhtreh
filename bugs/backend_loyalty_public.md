# Аудит публичных эндпоинтов лояльности

Проверены:
- `GET /loyalty/mechanics/levels/:merchantId`
- `POST /loyalty/mechanics/registration-bonus`
- `GET /loyalty/events/poll`

Ниже проблемы отсортированы по убыванию важности.

## P1 — Высокая важность

### 1) Регистрационный бонус можно получить повторно при гонках запросов
**Где:** `POST /loyalty/mechanics/registration-bonus` → `LoyaltyService.grantRegistrationBonus`.

**Проблема:** идемпотентность проверяется чтением `Transaction`/`EarnLot` до транзакции, без уникального ограничения на `orderId` в `Transaction` (и без уникального ключа в `EarnLot`). При двух параллельных запросах оба могут пройти проверку и начислить бонус дважды.

**Риск:** абуз начисления баллов, особенно если клиент/скрипт дергает endpoint одновременно (или при ретраях клиента).

**Что делать:** зафиксировать идемпотентность на уровне БД (уникальный ключ по `merchantId+customerId+orderId` в соответствующих таблицах) или делать проверку и запись в одной транзакции через `upsert`/`create` с уникальным constraint.

### 2) Проверка “не суммировать с рефералом” фактически отключена
**Где:** `LoyaltyService.grantRegistrationBonus`.

**Проблема:** блокировка для приглашённых клиентов (`stackWithRegistration === false`) выполняется внутри `try { ... } catch {}` и исключение проглатывается. В итоге бонус выдаётся даже когда программа рефералов запрещает суммирование.

**Риск:** неправильная бизнес‑логика и повторные начисления, которые нельзя отключить настройками.

**Что делать:** убрать “пустой catch” и возвращать ошибку при реальном запрете; обработать отдельно только ошибки БД (если нужно), а не бизнес‑исключения.

## P2 — Средняя важность

### 3) Публичный GET делает запись в БД (неявный сайд‑эффект)
**Где:** `GET /loyalty/mechanics/levels/:merchantId` → `ensureBaseTier`.

**Проблема:** публичный каталог уровней вызывает `ensureBaseTier`, который при отсутствии базового уровня создаёт его в БД. Это “mutating GET” без авторизации и без явного согласия мерчанта.

**Риск:** неконтролируемое изменение данных и появление дефолтных уровней (с дефолтными правилами), даже если мерчант не настраивал механику уровней или рассчитывал на ручную настройку.

**Что делать:** убрать создание из публичного GET (перенести в административный/портальный флоу), либо создавать базовый уровень только при явной настройке механики.

### 4) Нет проверки принадлежности `outletId`/`staffId` мерчанту
**Где:** `POST /loyalty/mechanics/registration-bonus` → `LoyaltyService.grantRegistrationBonus`.

**Проблема:** `outletId`/`staffId` принимаются из запроса и сохраняются без проверки, что они принадлежат текущему `merchantId`.

**Риск:** загрязнение аналитики и связей (начисление “на чужую точку/сотрудника”), возможные несогласованные связи в данных.

**Что делать:** валидировать `outletId`/`staffId` по `merchantId` или игнорировать эти поля в публичном эндпоинте.

## P3 — Низкая важность

### 5) Долгие удержания соединений в `events/poll`
**Где:** `GET /loyalty/events/poll` → `LoyaltyEventsService.waitForCustomerEvent`.

**Проблема:** endpoint держит long‑poll до ~25 секунд на запрос. При массовых одновременных опросах (даже от одного пользователя) это может занять все доступные воркеры/коннекты.

**Риск:** локальные деградации доступности мини‑аппы/эндпоинта при повышенной активности.

**Что делать:** ограничить число одновременных long‑poll запросов на пользователя/клиента или перевести на более “push”‑ориентированную механику (например, сокеты) при необходимости.
