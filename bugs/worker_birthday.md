# Аудит birthday worker (api/src/birthday.worker.ts)

Ниже проблемы отсортированы по убыванию критичности.

## P1 — критичные для продакшена

### 1) Абуза баллов через смену даты рождения клиентом
**Риск:** если клиент может обновлять поле `Customer.birthday` (через miniapp/портал/админку), он может менять дату несколько раз в году и получать бонусы повторно. Уникальность ограничена комбинацией `(merchantId, customerId, birthdayDate)`, поэтому новая дата обходит защиту. Это прямой абуз баллов и финансовые потери.
**Где:** `api/src/birthday.worker.ts` (использует актуальное `customer.birthday` без ограничений на частоту изменения). `api/prisma/schema.prisma` (`Customer.birthday`, `@@unique([merchantId, customerId, birthdayDate])` у `BirthdayGreeting`).
**Что проверить/исправить:**
- Ограничить изменение даты рождения (однократная установка или редкий лимит), либо хранить «validated birth date» отдельно.
- При выдаче подарка учитывать «год выдачи» и не выдавать повторно вне зависимости от смены даты.

### 2) Игнорирование блокировки начислений (`accrualsBlocked`) при выдаче подарка
**Риск:** клиенты, для которых начисления запрещены (фрод/долги/бан), всё равно получают подарочные баллы. Это нарушает антифрод-логику и позволяет обходить блокировки.
**Где:** `api/src/birthday.worker.ts` (в `collectCandidates` и `createGreeting` нет фильтра/проверки `Customer.accrualsBlocked`). `api/prisma/schema.prisma` (`Customer.accrualsBlocked`).
**Что проверить/исправить:**
- Исключать клиентов с `accrualsBlocked=true` на этапе отбора кандидатов.
- Либо в `createGreeting` не создавать подарок/транзакцию для таких клиентов.

## P2 — существенные риски качества/корректности

### 3) Неверный расчёт дня отправки из-за отсутствия часового пояса мерчанта
**Риск:** `startOfDay()` и сравнение дат используют локальный часовой пояс сервера, а не мерчанта. Для сетей в разных таймзонах поздравления могут уходить «на день раньше/позже», а подарки начисляться не в ожидаемую дату.
**Где:** `api/src/birthday.worker.ts` (`startOfDay`, `resolveBirthdayEvent`, `targetDate` от `new Date()`). В БД есть `Outlet.timezone`, но он не используется.
**Что проверить/исправить:**
- Нормализовать даты на таймзону мерчанта (или хранить TZ на уровне merchant/settings).
- Отправлять/создавать подарки в «локальный» день рождения клиента/мерчанта.

### 4) Фильтр «только покупатели» учитывает отменённые чеки
**Риск:** для условия `onlyBuyers` используется наличие `Receipt.total > 0` без исключения `canceledAt`. Это означает, что клиент может считаться покупателем даже по отменённому чеку → получать подарок без фактической покупки.
**Где:** `api/src/birthday.worker.ts` (`collectCandidates`), `api/prisma/schema.prisma` (`Receipt.canceledAt`).
**Что проверить/исправить:**
- В выборке учитывать только неотменённые чеки (`canceledAt: null`).

## P3 — надёжность/эксплуатация

### 5) «Нет получателей» блокирует повторные попытки навсегда
**Риск:** если на момент отправки нет push‑устройств (или бот не активирован), greeting получает статус `FAILED` с `error='no recipients'` и больше никогда не будет отправлен, даже если клиент позже активирует бота/приложение. Клиент не узнает о подарке.
**Где:** `api/src/birthday.worker.ts` (`resumePending` пропускает `FAILED` с `no recipients`, `sendGreeting` ставит `FAILED`).
**Что проверить/исправить:**
- Либо делать ретрай «no recipients» через время, либо переводить в отдельный статус и переобрабатывать при появлении push‑устройства.
- Альтернатива: показывать подарок в UI/портале независимо от push-уведомления.
