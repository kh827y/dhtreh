# Аудит: промокоды (merchant-portal/app/promocodes/page.tsx, /portal/promocodes)

Ниже — найденные проблемы и недоработки. Сортировка по убыванию важности.

## P1 — Высокая критичность

1. **Нет проверки, что `assignTierId` относится к текущему мерчанту (риск межтенантных ошибок)**
   - **Где:** `PromoCodesService.payloadToPrisma()` сохраняет `assignTierId` как пришёл из `PortalPromoCodePayload`, без проверки на принадлежность мерчанту; в `apply()` используется `loyaltyTier.findUnique({ where: { id: promo.assignTierId } })` без `merchantId` (то есть можно сослаться на любой tier по ID).
   - **Почему это важно:** при ручном запросе к `/portal/promocodes/issue` или `/portal/promocodes/:id` можно подставить `levelId` другого мерчанта (если ID известен/утёк) и тем самым «привязать» чужой уровень лояльности к клиентам текущего мерчанта. Это ломает изоляцию данных и может привести к некорректным начислениям/отображению уровней.
   - **Что проверить/ожидаемое поведение:** на бекенде валидировать, что `levelId` принадлежит `merchantId` из токена, и отклонять запросы с чужим `levelId`.

## P2 — Средняя критичность

2. **Список промокодов ограничен `limit=200` без пагинации → старые промокоды могут стать недоступны для управления**
   - **Где:** UI всегда запрашивает `/api/portal/promocodes?limit=200` и потом фильтрует по статусу на клиенте. Бекенд сортирует по `createdAt desc` и возвращает только последние 200 записей.
   - **Почему это важно:** если в системе накопится больше 200 промокодов, часть активных/архивных не будет отображаться и их невозможно отредактировать/архивировать через портал.
   - **Что проверить/ожидаемое поведение:** добавить пагинацию в UI или фильтр по статусу с отдельными запросами на активные/архивные (и/или увеличить лимит с постраничной навигацией).

3. **Дата начала/окончания промокода парсится как UTC, что даёт сдвиги по таймзоне и неверное автоархивирование**
   - **Где:** UI отправляет `validFrom/validUntil` в формате `YYYY-MM-DD`, а бекенд делает `new Date(payload.validFrom)`/`new Date(payload.validUntil)`.
   - **Почему это важно:** строка без времени интерпретируется как UTC, поэтому для мерчантов в не-UTC таймзонах промокод может стартовать/заканчиваться не в ожидаемую локальную дату (например, на день раньше/позже). Это особенно критично для акций «до конца дня».
   - **Что проверить/ожидаемое поведение:** хранить даты в локальной таймзоне мерчанта или явно добавлять время (например, `T00:00:00`/`T23:59:59`) с учётом `merchantTimezone`.

4. **Нет серверной валидации, что `validUntil` >= `validFrom`**
   - **Где:** `payloadToPrisma()` просто кладёт `activeFrom/activeUntil`, без проверки порядка.
   - **Почему это важно:** можно создать промокод, который никогда не станет активным (конец раньше старта), а UI не предупредит. Такой код начнёт сразу «самоархивироваться» или будет всегда недоступен.
   - **Что проверить/ожидаемое поведение:** на бекенде валидировать даты и возвращать понятную ошибку.

## P3 — Низкая критичность

5. **Нельзя сделать «безлимит на клиента» — UI всегда отправляет `perCustomerLimit`**
   - **Где:** `handleSave()` всегда шлёт `perCustomerLimit` (минимум 1). В результате бекенд переключает промокод в режим `LIMITED_PER_CUSTOMER`, даже если в интерфейсе нет намерения ограничивать.
   - **Почему это важно:** в продукте невозможно создать промокод с бесконечным количеством использований на одного клиента (например, «промокод на скидку, действует всегда»). Это ограничение функционала без явного переключателя.
   - **Что проверить/ожидаемое поведение:** добавить чекбокс «не ограничивать на клиента» и не отправлять `perCustomerLimit`, когда лимит не нужен.
