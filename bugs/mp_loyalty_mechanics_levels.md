# Аудит: merchant-portal — механика «Уровни клиентов»

## Критичные

### 1) Сервер не защищает базовые инварианты уровней (можно оставить систему без стартового уровня)
**Где:** `api/src/loyalty-program/loyalty-program.service.ts` (`updateTier`, `deleteTier`, `createTier`).

**Что происходит:** UI запрещает снимать флаг `isInitial`, скрывать стартовый уровень и удалять стартовый уровень, но сервер эти ограничения не проверяет. Через прямой вызов `/portal/loyalty/tiers` можно:
- снять флаг `isInitial` у последнего стартового уровня;
- удалить стартовый уровень (если нет назначенных клиентов);
- сделать стартовый уровень скрытым или скрыть единственный уровень.

**Почему это проблема:**
- В системе может не остаться стартового уровня, и новые клиенты не получат автоматического назначения уровня.
- При следующем `GET /portal/loyalty/tiers` сработает `ensureBaseTier` и создаст базовый уровень с дефолтными ставками (`Base`, 3%/50%), что неожиданно поменяет экономику начислений/списаний для мерчанта.

**Ожидаемое поведение:** все ограничения из UI должны быть продублированы на бекенде, чтобы невозможны были разрушительные состояния при прямом вызове API.

---

## Высокие

### 2) Переключение стартового уровня не атомарно и может оставить систему без стартового уровня
**Где:** `merchant-portal/app/loyalty/mechanics/levels/page.tsx` (логика `handleSave`, функция `unsetInitial`).

**Что происходит:** при назначении нового стартового уровня UI сначала делает `PUT` на старый уровень с `isInitial=false`, а затем отдельным запросом сохраняет новый уровень с `isInitial=true`. Если второй запрос падает (сетевая ошибка, валидация, 500), старый стартовый уровень уже снят, а новый не назначен.

**Почему это проблема:**
- Между запросами система остается без стартового уровня.
- При следующем списке уровней может автосоздаться дефолтный `Base` уровень (см. критичную проблему выше), что приведет к нежелательной смене настроек.

**Ожидаемое поведение:** смена стартового уровня должна быть атомарной (один серверный запрос, который снимает `isInitial` у старого и устанавливает у нового в транзакции).

---

## Средние

### 3) Нет серверной валидации верхней границы процентов списания/начисления
**Где:** `api/src/loyalty-program/loyalty-program.service.ts` (`sanitizePercent`, `createTier`, `updateTier`).

**Что происходит:** сервер принимает любое положительное значение процентов и молча нормализует его в BPS без верхнего лимита. UI ограничивает `% списания` до 100, но это ограничение можно обойти через прямой API-запрос.

**Почему это проблема:**
- В интерфейсах и отчетах могут появляться значения >100%, что противоречит бизнес-логике «% от суммы чека».
- Это создает риск некорректных ожиданий у мерчанта и путаницу в настройках (особенно если интеграции/клиенты читают эти значения напрямую).

**Ожидаемое поведение:** валидация верхней границы процентов на бекенде (например, 0–100 для списания).

---

## Низкие

### 4) Некорректные числовые значения тихо сбрасываются в 0
**Где:** `api/src/loyalty-program/loyalty-program.service.ts` (`sanitizePercent`, `sanitizeAmount`).

**Что происходит:** если передать в API невалидные значения (`"abc"`, `-1`, `NaN`), сервер без ошибки подставляет `0`. Это может незаметно «обнулить» настройки уровней.

**Почему это проблема:**
- Повышает риск случайной потери корректных значений при интеграциях или ошибках клиента.

**Ожидаемое поведение:** при невалидных данных возвращать 400 с описанием ошибки, чтобы избежать скрытого изменения настроек.
