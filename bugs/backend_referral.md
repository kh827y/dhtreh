# Аудит реферальной программы (backend)

## Критично

1. **[SEC][TENANT] Рефералы можно активировать/создавать «между» мерчантами (нарушение изоляции данных)**
   - `POST /referral/activate` принимает `refereeId` и активирует код без проверки, что `refereeId` принадлежит тому же мерчанту, что и программа из `code`. Валидации по мерчанту нет ни в контроллере, ни в `ReferralService.activateReferral`.
   - `GET /referral/link/:customerId` полагается на `merchantId` из query. Если его не передать, `getCustomerReferralLink` ищет «первую активную» программу без фильтра по мерчанту и создаёт персональный код на чужого мерчанта.
   - Риск: перемешивание данных, начисления/кошельки на чужие мерчанты, утечки и невозможность корректного учёта.

## Высокий

2. **[ABUSE] Сроки реферальной программы фактически не работают**
   - Поля `expiryDays`/`validUntil`, `referral.expiresAt`, `personalReferralCode.isActive` есть в схеме/создании программы, но нигде не используются при активации/начислении.
   - Итог: невозможность выключить код, отсутствие срока жизни ссылок/программ.

## Средний

3. **[ABUSE] Процентные награды не ограничены сверху для одноуровневых программ**
   - В `create/update` можно установить `rewardType=PERCENT` и `referrerReward > 100`, при этом при начислении процент берётся «как есть». Это позволяет выплачивать больше 100% от покупки.
   - Ограничение до 100% есть только в `normalizeLevels`, но для одноуровневых программ оно не применяется.

4. **[ABUSE] `POST /referral/complete` принимает невалидные суммы (NaN/Infinity) и может выдать награду без реальной покупки**
   - Валидации `purchaseAmount` нет: при `NaN` проверка минимальной суммы фактически обходится, а фиксированная награда начисляется.
   - Это позволяет начислять бонусы без покупки при доступе к API.
