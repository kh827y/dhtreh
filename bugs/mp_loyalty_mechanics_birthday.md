# Аудит: механика «Поздравление с днём рождения» и /portal/loyalty/mechanics

Ниже проблемы отсортированы по убыванию критичности.

## P1 — критичные для продакшена

### 1) Утечка секретов настроек через `/portal/settings` для сотрудников с доступом только к механикам
**Риск:** сотрудник с минимальными правами на механики (например, только `mechanic_birthday`) может получить чувствительные данные: `webhookSecret`, `bridgeSecret`, `telegramBotToken` и др., что открывает путь к компрометации интеграций и несанкционированным действиям.

**Почему так:** `assertSettingsReadAccess()` разрешает чтение `/portal/settings` при наличии прав на механики, а `getSettings()` возвращает все поля настроек, включая секреты.

**Где:**
- `api/src/portal/portal.controller.ts` → `assertSettingsReadAccess`, `getSettings`.
- `api/src/merchants/merchants.service.ts` → `getSettings` (выдаёт секреты).

**Что сделать:**
- ограничить доступ к полным настройкам только правом `system_settings`; или
- маскировать/исключить секреты из ответа для ролей, у которых нет `system_settings`.

## P2 — высокие (ошибки данных/логики)

### 2) Аналитика «потраченных подарочных баллов» считает покупки до фактической отправки поздравления
**Риск:** метрики `giftPointsSpent`, `revenueNet`, `receiptsWithGifts` завышаются — система приписывает траты подарочных баллов покупкам, совершённым до того, как подарок был выдан (то есть до `sendDate`). Это делает аналитику недостоверной и может привести к неверным управленческим решениям.

**Почему так:** при расчёте расхода подарочных баллов нет проверки, что `receipt.createdAt >= lot.sendDate`.

**Где:** `api/src/analytics/analytics.service.ts` → `getBirthdayMechanicMetrics`, блок расчёта `giftSpentByReceipt`.

**Что сделать:** учитывать подарочный лот только для чеков после `sendDate` (и до `expiresAt`).

### 3) Срезы статистики по датам считаются в UTC, а не в часовом поясе мерчанта
**Риск:** в графиках «Поздравления/Покупки» и «Выручка» часть событий попадает в соседние дни/недели при отличии таймзоны от UTC. В итоге мерчант видит смещённые пики и неверные сравнения по дням.

**Почему так:** бэкенд формирует ключи дат через `toISOString().slice(0,10)` (UTC), а фронт группирует/отображает эти даты также в UTC.

**Где:**
- `api/src/analytics/analytics.service.ts` → `dateKey` в `getBirthdayMechanicMetrics`.
- `merchant-portal/app/loyalty/mechanics/birthday/stats-utils.ts` → `bucketKey` и `formatBucketLabel`.

**Что сделать:** формировать ключи дат с учётом `req.portalTimezone` и отдавать уже «локальные» даты мерчанта (или передавать timezone в UI и корректно группировать на фронте).

### 4) Потеря legacy‑правил при сохранении настроек механики
**Риск:** если `rulesJson` хранится в legacy‑формате массива (который поддерживается бекендом), то сохранение настроек дня рождения перезаписывает его объектом только с `birthday`, теряя остальные правила. Дополнительно это приводит к требованию `system_settings` вместо прав на конкретную механику.

**Почему так:** `resolveRulesJson()` возвращает `{}` для не‑объектов, после чего `rules.birthday = ...` и полный `rulesJson` отправляется назад.

**Где:**
- `merchant-portal/app/api/portal/loyalty/birthday/route.ts` → `resolveRulesJson`, `PUT`.
- `api/src/merchants/merchants.service.ts` → `normalizeRulesJson` (поддержка массива).

**Что сделать:** корректно обрабатывать legacy‑массив (например, переводить его в объект с сохранением `rules`), либо запретить редактирование механик, пока правила в старом формате.

### 5) `/portal/loyalty/mechanics` не синхронизирован с фактическими настройками механики ДР
**Риск:** сторонние клиенты/внутренние страницы, использующие `/portal/loyalty/mechanics`, будут видеть пустые/устаревшие данные о механике ДР. При этом реальная работа механики определяется `rulesJson` и воркером, так что статус в `/portal/loyalty/mechanics` не отражает реальное состояние.

**Почему так:** таблица `loyaltyMechanic` и её CRUD не связаны с `rulesJson` и воркером ДР.

**Где:**
- `api/src/loyalty-program/controllers/mechanics.controller.ts`
- `api/src/loyalty-program/loyalty-program.service.ts`
- `merchant-portal/app/api/portal/loyalty/birthday/route.ts` (работает только с `rulesJson`).

**Что сделать:** либо синхронизировать механики с `rulesJson` (миграция на новый источник), либо пометить `/portal/loyalty/mechanics` как legacy и убрать из прод‑контуров.

## P3 — низкие (UX/ошибки использования)

### 6) Сохранение настроек возможно даже при ошибке загрузки
**Риск:** при сбое загрузки настроек форма остаётся с дефолтными значениями, и пользователь может нажать «Сохранить», перезаписав реальные настройки дефолтами (ошибочная конфигурация).

**Почему так:** UI не блокирует сохранение при `error` и использует дефолтный state как валидные значения.

**Где:** `merchant-portal/app/loyalty/mechanics/birthday/page.tsx` → `SettingsTab`.

**Что сделать:** блокировать сохранение до успешной загрузки или явно показывать «не загружено — сохранение недоступно».
