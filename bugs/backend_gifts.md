# Аудит gifts (backend)

Ниже — найденные проблемы по убыванию критичности. Проверялись эндпоинты:
`GET /gifts/:merchantId`, `POST /gifts`, `PUT /gifts/:giftId`, `POST /gifts/:merchantId/:giftId/redeem`.

## P0 — Критичные

1) **Публичное списание баллов без аутентификации и проверки владельца**
   - `POST /gifts/:merchantId/:giftId/redeem` не защищён guard’ами и принимает `customerId` из body.
   - Любой клиент может указать чужой `customerId` и списать баллы у другого пользователя.
   - Это прямой абуз баллов и финансовые потери (нет проверки Telegram initData/сессии/подписи).

2) **Если `customerId` не передан, списание может уйти с «первого попавшегося» кошелька мерчанта**
   - В контроллере `customerId` берётся из body без обязательной валидации.
   - В сервисе `wallet.findFirst({ where: { merchantId, customerId, type: 'POINTS' } })` с `customerId = undefined` приводит к поиску по `merchantId` (поле игнорируется), что потенциально списывает баллы у произвольного клиента мерчанта.
   - Это критичная логическая уязвимость/абуз.

## P1 — Высокие

1) **Лимит `perCustomerLimit` проверяется вне транзакции → обход лимита при параллельных запросах**
   - Проверка количества `giftRedemption` делается до транзакции; при конкурентных запросах лимит может быть превышен.
   - Нужна проверка/блокировка внутри транзакции или уникальные ограничения/селекты с блокировкой.

2) **Инвентарь уменьшается неатомарно → возможен оверселл**
   - В транзакции идёт `findUnique` + `update` с вычисленным значением.
   - При параллельных запросах можно несколько раз прочитать один и тот же `inventory` и одновременно списать, что даёт отрицательный остаток/оверселл.
   - Лучше использовать атомарное условное обновление (`update ... where inventory > 0`) или блокировку строки.

3) **Нет идемпотентности на списание подарка**
   - Повторный вызов `redeem` (из‑за ретраев клиента/плохой сети) списывает баллы повторно и создаёт несколько редемпшенов.
   - Для списаний нужен идемпотентный ключ или проверка на повторную операцию для того же запроса.

## P2 — Средние

1) **Портал мерчанта получает только активные/актуальные подарки**
   - `GET /portal/gifts` использует `listGifts`, который фильтрует `active = true` и период.
   - В результате в портале нельзя увидеть/редактировать выключенные или запланированные подарки → настройки «теряются».
   - Для портала нужен отдельный эндпоинт без этих фильтров.

2) **Генерация `code` без обработки коллизий**
   - `code` имеет уникальное ограничение, но `randCode()` не проверяет конфликт и не делает retry.
   - При коллизии запрос упадёт 500‑й ошибкой (редко, но возможно под нагрузкой).

3) **`createGift` может создать «мерчанта‑заглушку»**
   - `ensureMerchant()` делает `upsert` и создаёт мерчанта с `name = merchantId`, если тот не существует.
   - Это маскирует ошибки и приводит к мусорным записям (особенно если `merchantId` в запросе неверный).
   - Логичнее валидировать существование мерчанта и возвращать ошибку.
