# Аудит: импорт клиентов (merchant-portal) и /import-export/*

Ниже проблемы отсортированы по убыванию важности устранения.

## P1 — High

### 1) Глобальный API ключ для /import-export/* не ограничен мерчантом
**Риск:** любой, кто получил `API_KEY`, может экспортировать/импортировать данные любого мерчанта, просто подставив `merchantId`. Это критично для ПДн (клиенты/транзакции) и может привести к массовому компромету/подмене данных.

**Где:**
- `api/src/import-export/import-export.controller.ts` — все методы принимают `merchantId` из query/body без проверки принадлежности ключу.
- `api/src/guards/api-key.guard.ts` — ключ общий для всего API, без scoping по мерчанту.

**Почему это проблема для продакшена:** это единая «мастер‑кнопка» на доступ ко всем данным сразу, без разграничения между компаниями.

**Как исправить (без overengineering):**
- перейти на ключи, привязанные к `merchantId` (таблица интеграций/мерчант‑ключей) или
- минимально: подписывать `merchantId` отдельным секретом (HMAC) и проверять его на стороне API.

## P2 — Medium

### 2) Импорт «детальных операций» фактически не создаёт транзакции и не отражается в истории клиента
**Риск:** UI обещает «детальную информацию об операциях», но импорт пишет только `Receipt`, без `Transaction`/ledger‑записей. В результате:
- история операций клиента может быть пустой/неполной (портал читает `transaction`),
- аналитика, завязанная на транзакции, остаётся некорректной,
- у мерчанта нет полноценного аудита начислений/списаний.

**Где:**
- `api/src/import-export/import-export.service.ts` — при импорте операций создаётся только `receipt` (без `transaction`).
- `api/src/portal/customers.service.ts` — UI формирует историю в основном по `transactions`.

**Как исправить (без overengineering):**
- при импорте операций создавать соответствующие `Transaction`/ledger‑записи (или явно отказаться от обещания «детальной информации об операциях» в UI и шаблонах).

### 3) Отсутствуют лимиты на размер загружаемых файлов, всё читается в память
**Риск:** большой файл может привести к OOM, долгим GC‑паузам и падению сервиса (DoS через импорт). Это затрагивает и portal‑импорт, и `import-export` API.

**Где:**
- `api/src/portal/portal.controller.ts` — `@UseInterceptors(FileInterceptor('file'))` без лимитов.
- `api/src/import-export/import-export.controller.ts` — тот же паттерн без ограничений.

**Как исправить (без overengineering):**
- задать `limits` для `FileInterceptor` (например, 5–20 MB),
- при превышении размера возвращать понятную ошибку.

### 4) Импорт клиентов в portal всегда перезаписывает существующих клиентов без выбора режима
**Риск:** любая ошибка в файле перетирает текущие данные (email/телефон/ФИО) без подтверждения. Это повышает вероятность порчи CRM‑данных, особенно при повторных импортах.

**Где:**
- `api/src/portal/portal.controller.ts` — `updateExisting: true` задано жёстко.
- `merchant-portal/app/customers/import/page.tsx` — в UI нет выбора стратегии (`только новые` vs `обновлять существующих`).

**Как исправить (без overengineering):**
- добавить явный переключатель «Обновлять существующих» и по умолчанию ставить `false`,
- или как минимум предупреждать пользователя о том, что импорт перезаписывает данные.
