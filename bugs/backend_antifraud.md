# Антифрод: аудит backend

Ниже проблемы отсортированы по убыванию критичности.

## P0 — Critical

1. **GET `/antifraud/history/:customerId` допускает утечку данных между мерчантами при отсутствии `merchantId`**
   - **Риск**: при запросе без `merchantId` Prisma игнорирует фильтр `merchantId: undefined` и отдаёт историю транзакций по `customerId` из любых мерчантов.
   - **Где**: `AntifraudController.getFraudHistory()` → `AntiFraudService.getCustomerHistory()`.

2. **GET `/antifraud/history/:customerId` возвращает аудит антифрода по всем клиентам мерчанта**
   - **Риск**: в ответе на историю конкретного клиента приходят записи `adminAudit` по всем клиентам мерчанта — утечка факторов/контекста других клиентов.
   - **Причина**: `getCustomerHistory()` фильтрует `adminAudit` только по `merchantId` и `actor`, без `customerId`.

3. **GET `/antifraud/stats` без `merchantId` выдаёт агрегаты по всем мерчантам**
   - **Риск**: статистика по всем компаниям доступна любому, кто знает общий API‑ключ.
   - **Причина**: в Prisma фильтр `merchantId: undefined` игнорируется.

## P1 — High

4. **Все антифрод‑эндпоинты защищены одним глобальным `API_KEY` без привязки к мерчанту**
   - **Риск**: утечка ключа = доступ к истории/статистике и возможностям ревью по всем мерчантам; нет tenant‑изоляции.
   - **Где**: `ApiKeyGuard` + отсутствует проверка связи ключа и `merchantId`.

5. **POST `/antifraud/:checkId/review` не проверяет существование проверки и не привязан к мерчанту**
   - **Риск**: можно записывать фальшивые ревью, подставляя `checkId` и `reviewedBy`; данные аудита легко загрязнить, нет трассируемости.
   - **Причина**: метод просто пишет в `adminAudit` без `merchantId` и без проверки `FraudCheck`.

6. **POST `/antifraud/check` принимает невалидные/неполные данные без валидации**
   - **Риск**: `merchantId`/`customerId` могут быть пустыми/`undefined`, `amount` может быть `NaN`/строкой/отрицательным — это ломает корректность скоринга и может использоваться для обхода крупных сумм.
   - **Причина**: нет DTO с `class-validator` и явной валидации входа.

## P2 — Medium

7. **POST `/antifraud/check` не сохраняет результат проверки и не использует `transactionId`**
   - **Риск**: нет полной истории проверок, аналитика/расследования невозможны; `transactionId` из запроса игнорируется.
   - **Причина**: `checkFraud()` вызывает только `checkTransaction()`, не использует `recordFraudCheck()`.

8. **Черный список фактически не работает**
   - **Риск**: правило `blacklisted_customer` никогда не срабатывает → невозможно блокировать известных нарушителей.
   - **Причина**: `checkBlacklist()` всегда возвращает `false` (заглушка).

9. **Проверка геолокации — заглушка**
   - **Риск**: фактор `location_jump` не срабатывает, хотя API принимает `location` → ложное ощущение защиты.
   - **Причина**: `distance = 0` и отсутствует реальный расчет расстояния.

10. **Антифрод ведёт себя fail‑open при любой ошибке**
   - **Риск**: сбой БД/Prisma/логики → транзакции всегда получают LOW‑риск и проходят без блокировки.
   - **Причина**: общий `try/catch` в `checkTransaction()` возвращает `RiskLevel.LOW`.

## P3 — Low

11. **Сырые технические сигналы легко обходятся и могут давать шум**
   - **Риск**: отсутствие нормализации/обогащения IP/UA делает факторы неустойчивыми; локальные IP или `curl` могут не отражать реальное злоупотребление, повышая ложные срабатывания.
   - **Причина**: проверяются только примитивные шаблоны без реальных источников (например, прокси‑цепочки, устройства, гео‑обогащение).
